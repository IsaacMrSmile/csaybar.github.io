---
title: "Integrating Earth Engine with Tensorflow I - DNN"
author: "Cesar Aybar" 
date: "2019-05-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval = FALSE)
```
|
<center>
<img src="https://raw.githubusercontent.com/csaybar/EEwPython/master/images/colab_ee_integration.png">
</center>  

## Topics

1. Create a training/testing dataset (in a TFRecord format) using Earth Engine.
2.  Create functions for parse data (TFRecord -> tf.data.Dataset).
3.   Training and Test a simple Vanilla Deep Neural Network using tensorflow 2.0.
3.   Making predictions on image data exported from Earth Engine in TFRecord format.
4.   Upload your results to Earth Engine (asset).




## 1. Introduction

Deep learning has dramatically improved the state-of-the-art in various science domains. For remote sensing, its potential has not been thoroughly explored. This could be related to the problematic incorporation of spectral & spatial features into a regular deep learning classification scheme or the huge pre-processing that satellite images could need it. Hence, this post aims to teach you how to create a painless deep learning pipeline integrating [Google Earth engine](https://earthengine.google.com/) for acquiring spectral & spatial data and [tensorflow](https://www.tensorflow.org/?hl=en) for train and test the model and make predictions.


## 2. What is Google Earth Engine (GEE)?

In a nutshell, is a platform that combines a multi-petabyte [catalog of satellite imagery](https://developers.google.com/earth-engine/datasets/) with planetary-scale analysis capabilities. There are several ways to interact with GEE:

  - [Explorer](https://explorer.earthengine.google.com/)
  - [Code Editor](https://code.earthengine.google.com/)  
  - [Javascript wrapper library](https://github.com/google/earthengine-api/tree/master/javascript)
  - [**Python wrapper library**](https://github.com/google/earthengine-api/tree/master/python)

In my opinion, the **Python wrapper library** (used in this post) is the best choice to interact with GEE for the following reasons:

- Easy to share code.
- Easy transition to a web application.
- Possibility to integrate with  ML/DL frameworks.
- Many plotting options (folium, plotly, matplotlib, seaborn ,etc.).

One more thing!, it's possible to run the Earth Engine Python API in a cloud environment for free, See this section of our [EE course introduction](https://colab.research.google.com/github/csaybar/EEwPython/blob/dev/1_Introduction.ipynb).

## 3.  Deep Neural Network (DNN)

<center>
<image src="https://www.electronicdesign.com/sites/electronicdesign.com/files/MachineLearning_WTD_Fig3.png">
</center>
  
A DNN is simply a neural network with more than two layers. The main steps for building a DNN are:

1. Initialize the model's parameters.
2. Loop:
    - Calculate current loss (forward propagation) :    
    - Calculate current gradient (backward propagation)
    - Update parameters (gradient descent)

The second step could be  a little intimidating, but don't worry about it!. **tf.keras**, the TensorFlow's high-level API, only need that you define the forward propagation correctly and all the steps further down will make automatically. This post does not intend to introduce the algorithm, check out this [repo](https://github.com/csaybar/DLcoursera) for a from zero (numpy) implementation.

## 4. Crop Area estimation in Camana Valley

Agriculture is part of the backbone Peruvian economy, contributing about 7.6% of the Gross Domestic Product (GDP), being more critical in rural areas where the contribution of GDP increase until 50%. In terms of people, this activity act for the primary source of income for 2.3 million families, representing 34% of Peruvian households. Despite agriculture importance in Peruvian family lives, today no exist a cropping system either at a national or regional scale that monitoring the extension, state, or crop type. Considering this problematic, in this section you will create a straightforward methodology to **predict the crop area** in Camana (Arequipa) Valley using a Deep Neural Network.

<center>
<img src='https://st.depositphotos.com/1171712/3974/i/950/depositphotos_39741899-stock-photo-camana-valley.jpg'>
</center>

### 4.1. Installing
Before coding do not forget install and load the following packages and remenber that you can communicate with the bash console prepending an ! to the code. 

```{python, eval=FALSE}
!pip install -q tf-nightly-2.0-preview #tensorflow 2.0
!pip install earthengine-api #earthengine API
# Load the TensorBoard notebook extension
%load_ext tensorboard
```

### 4.2. Authentification
For interacting with Google services, it's necessary to authenticate (as yourself). The code below accomplishes this task.

#### Google Cloud

Google Cloud Storage bucket will serve as a bridge between GEE and Colab.
```{python, eval = FALSE}
from google.colab import auth
auth.authenticate_user()
```

#### Google Earth Engine

```{python, eval = FALSE}
!earthengine authenticate
```

### 4.3. Initialize and testing the software setup

```{python, eval = FALSE}
# Earth Engine Python API
import ee 
ee.Initialize()

import tensorflow as tf
print('Tensorflow version: ' + tf.__version__)

import folium
print('Folium version: ' + folium.__version__)

# Define the URL format used for Earth Engine generated map tiles.
EE_TILES = 'https://earthengine.googleapis.com/map/{mapid}/{{z}}/{{x}}/{{y}}?token={token}'
```

### 4.4. Prepare the Dataset

Firstly, we define our prediction area (Camana Valley) and passing to GEE. For moving a vector to GEE, we can use the `ee.Geometry.*` module. The [GeoJSON](https://geojson.org/) spec describes in detail the type of geometries supported by GEE, including `Point` (a list of coordinates in some projection), `LineString` (a list of points), `LinearRing` (a closed LineString), and `Polygon` (a list of LinearRings where the first is a shell and subsequent rings are holes). GEE also supports **MultiPoint**, **MultiLineString**, and **MultiPolygon**. The [GeoJSON](https://geojson.org/) GeometryCollection is also supported, although it has the name **MultiGeometry** within GEE.


```{python ,eval=FALSE}
# 4.4.1 Prediction Area
xmin,ymin,xmax,ymax = [-72.778645, -16.621663, -72.66865, -16.57553]

xmed = (xmax + xmin)/2
ymed = (ymax + ymax)/2

# Passing a rectangle (prediction area) to Earth Engine
Camana_valley = ee.Geometry.Rectangle([xmin,ymin,xmax,ymax])

m = folium.Map(
    location=[ymed, xmed],
    zoom_start=7    
)
folium.Rectangle([[ymax,xmin],[ymin,xmax]],popup='Camana',name='Landsat8-2018',fill=True).add_to(m)
m
```

```{r eval=TRUE,echo=FALSE,highlight=FALSE,warning=FALSE,message=FALSE}
xmin =-72.778645
ymin =-16.621663
xmax =-72.66865
ymax = -16.57553
library(mapview)
library(sf)
polygon_m = matrix(c(xmin,ymin,xmin,ymax,xmax,ymax,xmax,ymin,xmin,ymin),ncol=2, byrow=TRUE)
camana = st_sfc(st_polygon(list(polygon_m)))
st_crs(camana) = 4326
mapview(camana,popup='Camana Valley')
```


Next, you create a visualization (with folium!) of the train and test dataset. We've already generated some points with the label agriculture/non-agriculture.

- Train dataset (550 points):
  - 275 labeled as "agriculture"
  - 275 labeled as "non agriculture" 
  
- Test dataset (100 points):
  - 50  labeled as "agriculture"
  - 50  labeled as "non agriculture"

```{python, eval=FALSE}
# 4.4.2 Importing the train/test dataset
import pandas as pd
import numpy as np

train_agriculture = ee.FeatureCollection('users/csaybar/DLdemos/train_set') 
test_agriculture = ee.FeatureCollection('users/csaybar/DLdemos/test_set')

# Passing data of Earth Engine to Python(pandas)
xy_agr = train_agriculture.geometry().getInfo()['coordinates']
df_agr = pd.DataFrame(xy_agr,columns=['Longitude','Latitude'])
df_agr['class'] = 'train'

xy_nonagr = test_agriculture.geometry().getInfo()['coordinates']
df_nonagr = pd.DataFrame(xy_nonagr,columns=['Longitude','Latitude'])
df_nonagr['class'] = 'test'

#Create a boundary Conditions
maxmincoord = pd.concat([df_nonagr[['Longitude','Latitude']].agg({'min','max'}),
                         df_agr[['Longitude','Latitude']].agg({'min','max'})])
xmax, xmin = maxmincoord['Longitude'].max(), maxmincoord['Longitude'].min()
ymax, ymin = maxmincoord['Latitude'].max(), maxmincoord['Latitude'].min()
db_area = ee.Geometry.Rectangle([xmin, ymin, xmax, ymax])

# Passing the dataset to folium!
df_agr.apply(lambda row: folium.CircleMarker(location=[row['Latitude'], row['Longitude']],
                                             radius=10, fill_color='blue').add_to(m), axis=1)

df_nonagr.apply(lambda row: folium.CircleMarker(location=[row['Latitude'], row['Longitude']],color='red',
                                                radius=10, fill_color='red').add_to(m), axis=1)
m
```


```{r eval=TRUE,echo=FALSE,highlight=FALSE,warning=FALSE,message=FALSE}
library(dplyr)
library(sp)
library(sf)
library(mapview)
dataset = read.csv('../../data/px.csv')[2:4]
coordinates(dataset) = ~Longitude+Latitude
dt = st_as_sf(dataset)
st_crs(dt) = 4326
mapview(dt,zcol = "class")
```

You will obtain the input data for mapping the **Camana crop area** of  [Landsat 8 OLI/TIRS (L8)](https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C01_T1_SR). GEE provides L8 images with radiometric and geometry correction. Additionally, **cloud mask information** is provided by means of the bit image `pixel_qa`. The following function allows putting NA to the TOA reflectance values of clouds.

```{python,eval=FALSE}
def maskS2clouds(img):
  '''  
  Function to mask clouds based on the pixel_qa band of Landsat 8 SR data. See:
  https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C01_T1_SR
  
  Params:
  -------
  - img: image input Landsat 8 SR image
  
  Return:
  -------
  cloudmasked Landsat 8 image
  '''
  cloudShadowBitMask = (1 << 3)
  cloudsBitMask = (1 << 5)
  # Get the pixel QA band.
  qa = img.select('pixel_qa')
  # Both flags should be set to zero, indicating clear conditions.
  mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0)\
           .And(qa.bitwiseAnd(cloudsBitMask).eq(0))
  return img.updateMask(mask)
```

Now you filtering and reducing the entire Landsat-8 dataset, considering the following:

1. Select only bands with spatial resolution of **30 meters**.

2. Filter considering the cloud pixel percentage by scene (< 20%).

3. Filter considering a date (we just selecting 1 years)

4. Apply **mask2cloud** to each image.

5. Get the median of the ImageCollection.

6. Clip the image considering study area.

To apply a function on all the elements of specified `ImageCollection` or `FeatureCollection` you can use `.map()`. The only argument that map() receive is a function which takes one parameter: an `ee.Image`.


```{python}
# 4.4.3 Prepare the satellite image (Landsat-8)
RGB_bands = ['B4','B3','B2'] #RGB
NDVI_bands = ['B5','B4'] #NIR

l8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")\
               .filterBounds(db_area)\
               .filterDate('2018-01-01', '2018-12-31')\
               .filter(ee.Filter.lt('CLOUD_COVER', 20))\
               .map(maskS2clouds)\
               .median()\
               .multiply(0.0001)

l8_ndvi = l8.normalizedDifference(NDVI_bands).rename(['NDVI'])
l8_rgb = l8.select(RGB_bands).rename(['R','G','B']) 
l8 = l8_rgb.addBands(l8_ndvi)
```


```{python}
# Create a visualization with folium
visParams_l8 = {    
  'bands': ['R', 'G', 'B'],
  'min': 0,
  'max': 0.5,
  'gamma': 1.4,
}

l8Mapid = l8.getMapId(visParams_l8)

folium.TileLayer(
  tiles=EE_TILES.format(**l8Mapid),
  attr='Google Earth Engine',
  overlay=True,
  name='Landsat8 2018',
).add_to(m)


m.add_child(folium.LayerControl())
m
```


For the collocation of the train/test datasets to each L8 grid cell value you will use the `ee.Image.sampleRegions` function. Note that geometries will be snapped to pixel centers (nearest center approximation).

```{python}
# 2.4.3 Extract pixels values considering train/test dataset
train_db = l8.sampleRegions(collection=train_agriculture, properties=['class'], scale=30)
test_db = l8.sampleRegions(collection=test_agriculture, properties=['class'], scale=30)

```


Unfortunately, you do not can use Tensorflow directly in Earth Engine. To overcome this problem we materialize the train/test dataset in a place where the TensorFlow model has access to them (Cloud Storage bucket). 

```{python}
# 2.4.4 Save results in Google Cloud Storage
outputBucket = 'bag_csaybar'

# Make sure the bucket exists.
print('Found Cloud Storage bucket.' if tf.io.gfile.exists('gs://' + outputBucket) 
    else 'Output Cloud Storage bucket does not exist.')

trainFilePrefix = 'TrainingAgriculture_'
testFilePrefix = 'TestAgriculture_'

# Create the tasks for passing of GEE to Google storage
trainingTask = ee.batch.Export.table.toCloudStorage(
  collection=train_db,
  description='Training Export',
  fileNamePrefix=trainFilePrefix,
  bucket=outputBucket,
  fileFormat='TFRecord')

testingTask = ee.batch.Export.table.toCloudStorage(
  collection=test_db,
  description='Testing Export',
  fileNamePrefix=testFilePrefix,
  bucket=outputBucket,
  fileFormat='TFRecord')

trainingTask.start()
testingTask.start()
```

You can be monitoring your progress with the code below:

```{python}
import time 
while trainingTask.active():
  print('Polling for task (id: {}).'.format(trainingTask.id))
  time.sleep(5)
while testingTask.active():
  print('Polling for task (id: {}).'.format(testingTask.id))
  time.sleep(5)

print('Done!')
```

### 4.5. Creating a tf.data.Dataset from a TFRecord file

```{python}
# Fullname train/test db
fileNameSuffix = 'ee_export.tfrecord.gz'
trainFilePath = 'gs://' + outputBucket + '/' + trainFilePrefix + fileNameSuffix
testFilePath = 'gs://' + outputBucket + '/' + testFilePrefix + fileNameSuffix
```

Passing data from the TFRecord file into a tf.data.Dataset. Preprocess the dataset to get it into a suitable format for input to the keras model. For getting more details about  `tf.data.Dataset` see the next [TFdoc](https://www.tensorflow.org/guide/premade_estimators#create_input_functions).

```{python}
def input_fn(fileNames, numEpochs=None, shuffle=True, batchSize=16):
  # Creates a `TFRecordDataset` 
  dataset = tf.data.TFRecordDataset(fileNames, compression_type='GZIP')

  feature_columns = {
    'R': tf.io.FixedLenFeature([], dtype=tf.float32),  
    'G': tf.io.FixedLenFeature([], dtype=tf.float32),  
    'B': tf.io.FixedLenFeature([], dtype=tf.float32),    
    'NDVI': tf.io.FixedLenFeature([], dtype=tf.float32),    
    'class': tf.io.FixedLenFeature([], dtype=tf.float32)
  }
  
  def parse(example_proto):
    parsed_features = tf.io.parse_single_example(example_proto, feature_columns)    
    # Separate the class labels from the training features
    labels = parsed_features.pop('class')
    return parsed_features, tf.cast(labels, tf.int32)
  dataset = dataset.map(parse, num_parallel_calls=5)
  if shuffle:
    dataset = dataset.shuffle(buffer_size = batchSize * 10)
  dataset = dataset.batch(batchSize)
  dataset = dataset.repeat(numEpochs)
  
  return dataset
```

```{python}
train_dba = input_fn(trainFilePath,100,True,32)
test_dba = input_fn(testFilePath, numEpochs=1, batchSize=1, shuffle=False)
```

### 4.6. Create a DNN model with keras

Here you will create a deep neural network model with:

  - 2 layers (10x10 nodes).
  - 1 dropout layer.
  - 1 output layer.

Additionally, `Early Stopping`, `Tensorboard` and `ModelCheckpoint` callbacks were added. A callback is a set of functions to be applied at given stages of the training procedure. You can found more details [here](https://keras.io/callbacks/).

```{python}
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from tensorflow import feature_column
import os
import datetime

bands = ['R','G','B','NDVI']

# Create a dense `Tensor` based on given `feature_columns`
feature_columns = [feature_column.numeric_column(x) for x in bands]
feature_layer = tf.keras.layers.DenseFeatures(feature_columns)

#initialize dnn model
he_init = tf.keras.initializers.he_uniform(seed=None)

# Define the layers in the model.
model = tf.keras.Sequential([
  feature_layer,  
  layers.Dense(10, activation='relu',kernel_initializer=he_init),
  tf.keras.layers.Dropout(0.2),
  layers.Dense(10, activation='relu',kernel_initializer=he_init),
  layers.Dense(1, activation='sigmoid',kernel_initializer=he_init)
])

#Callbacks
logdir = os.path.join("logs", datetime.datetime.now().strftime("%Y%m%d-%H%M%S"))
tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir, histogram_freq=1)
es = EarlyStopping(monitor='val_loss', patience=10)
mcp = ModelCheckpoint(filepath='best_model.h5', monitor='val_loss', save_best_only=True)


# Compile the model with the specified loss function.
model.compile(optimizer=keras.optimizers.SGD(momentum=0.01, nesterov=True),
              loss='binary_crossentropy',              
              metrics=['accuracy'])

# Fit the model to the training data.
model.fit(x=train_dba,
          epochs=15,
          steps_per_epoch=100,
          callbacks=[tensorboard_callback,es,mcp],
          validation_data=test_dba)
```

Starts tensorboard!

```{python}
%tensorboard --logdir logs
```

<img src='https://raw.githubusercontent.com/csaybar/csaybar.github.io/master/img/tensorboard.png'>

```{python}
model.load_weights("best_model.h5")
model.evaluate(x = test_dba)
```

### 4.7. Prediction

At this step you must be have the model fitted, great work!. In this section you export l8 imagery using ee.batch.Export.image.toCloudStorage a similar.

```{python}
l8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR")\
               .filterBounds(Camana_valley)\
               .filterDate('2018-01-01', '2018-12-31')\
               .filter(ee.Filter.lt('CLOUD_COVER', 20))\
               .map(maskS2clouds)\
               .median()\
               .multiply(0.0001)\
               .clip(Camana_valley)

l8_ndvi = l8.normalizedDifference(NDVI_bands).rename(['NDVI'])
l8_rgb = l8.select(RGB_bands).rename(['R','G','B']) 
l8 = l8_rgb.addBands(l8_ndvi)
```

```{python}
imageFilePrefix = 'Camana_DNN'

# Specify patch and file dimensions.
imageExportFormatOptions = {
  'patchDimensions': [128, 128],
  'maxFileSize': 104857600,
  'compressed': True
}

# Setup the task.
imageTask = ee.batch.Export.image.toCloudStorage(
  image=l8,
  description='Image Export',
  fileNamePrefix=imageFilePrefix,
  bucket=outputBucket,
  scale=30,
  fileFormat='TFRecord',
  region=Camana_valley.getInfo()['coordinates'],
  formatOptions=imageExportFormatOptions,
)

imageTask.start()
```

```{python}
import time 
while imageTask.active():
  print('Polling for task (id: {}).'.format(imageTask.id))
  time.sleep(5)
```

